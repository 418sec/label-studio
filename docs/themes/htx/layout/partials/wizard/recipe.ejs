<script>
class Recipe {
  objects = []
  controls = []
  details = false

  constructor(recipe, el) {
    this.recipe = recipe
    this.element = el

    this.parse()
  }

  toggleDetails() {
    this.element.querySelector('.details').style.display = this.details ? 'none' : 'block'
    this.element.querySelector('[name=details]').textContent = this.details ? 'Show details' : 'Configure setup'

    this.details = !this.details
  }

  flatten(el) {
    const tags = []
    for (let tag of el.children) {
      tags.push(tag)
      if (tag.children.length) tags.push(...this.flatten(tag))
    }
    return tags
  }

  fixXML(xml) {
    return xml.replace(/<(\w+)(.*?)\/>/ig, '<$1$2></$1>').replace(/<img (.*?)>/, '<Image $1 />')
  }

  labelInit($label) {
    // @todo always?
    $label.$control = $label.parentNode
    const lbl = TPLS.label.use({
      span: $label.getAttribute('value')
    }, $label.$control._tag.querySelector('ul'))
    let color = $label.getAttribute('background')
    if (color && color[0] !== '#') color = colorNames[color]
    if (!color) color = PALETTE[paletteIndex++ % PALETTE.length]
    $label.setAttribute('background', color)
    lbl.querySelector('.color').value = color
    lbl.querySelector('.color').oninput = e => this.labelEdit($label, { background: e.target.value })
    lbl.querySelector('.delete').onclick = () => this.labelDelete($label)
    $label._tag = lbl
  }

  labelAdd(text, $control) {
    const $label = document.createElement("Label")
    $label.setAttribute("value", text)
    $control.appendChild($label)
    this.labelInit($label)
  }

  labelEdit($label, data) {
    for (let key in data) {
      $label.setAttribute(key, data[key])
    }
    this.render()
  }

  labelDelete($label) {
    $label.$control.removeChild($label)
    $label._tag.parentNode.removeChild($label._tag)
    this.render()
  }

  _render() {
    const config = this.fixXML(this.config.innerHTML)
    const host = 'https://app.heartex.ai'
    $.ajax({
      url: host + '/demo/render-editor?full_editor=t&playground=1',
      method: 'POST',
      xhrFields: { withCredentials: true },
      data: { config },
      success: data => {
        const iframe = document.querySelector('.lsf iframe')
        iframe.setAttribute('srcdoc', data)
      },
      error: function () {
        $('#preload-editor').show();
      }
    })
  }

  render = debounce(this._render.bind(this), 250)

  parse() {
    const config = document.createElement('div')
    this.config = config
    config.innerHTML = this.fixXML(this.recipe.config)

    this.element.querySelector('.details').innerHTML = this.recipe.details
    const $details = this.element.querySelector('[name=details]')
    $details.onclick = () => this.toggleDetails()

    const tags = this.flatten(config)
    this.objects = tags.filter($tag => Object.keys(OBJECT_TAGS).includes($tag.tagName.toLowerCase()))
    const names = this.objects.map($tag => $tag.getAttribute('name'))
    this.controls = tags.filter($tag => names.includes($tag.getAttribute('toname')))

    for (let $object of this.objects) {
      const object = OBJECT_TAGS[$object.tagName.toLowerCase()]
      $object._tag = this.element.querySelector('.configure__object')
      $object._tag.querySelector('.object__type').textContent = object.type
      $object.$controls = this.controls.filter($tag => $tag.getAttribute('toname') === $object.getAttribute('name'))
      $object.$controls.forEach($control => $control.$object = $object)

      this.element.querySelector('.configure__settings .object__type').textContent = object.type

      let settings = object.settings
      $object.$controls.forEach($control => {
        let type = $control.tagName.toLowerCase()
        if (CONTROL_TAGS[type]) {
          settings = { ...settings, ...CONTROL_TAGS[type].settings }
        }
      })
      Object.values(settings).forEach(options => {
        const li = document.createElement('li')
        let label
        switch (options.type) {
          case Boolean:
            const checkbox = document.createElement('input')
            checkbox.type = 'checkbox'
            checkbox.onchange = e => {
              if (typeof options.param === "function") {
                options.param(options.control ? $object.$controls[0] : $object, e.target.checked)
              } else {
                $object.setAttribute(options.param, e.target.checked ? 'true' : 'false')
              }
              this.render()
            }
            label = document.createElement('label')
            label.appendChild(checkbox)
            label.appendChild(document.createTextNode(options.title))
            li.appendChild(label)
            break;
          case String:
          case Number:
            const input = document.createElement('input')
            input.type = 'text'
            if (options.type === Number) input.size = 5
            input.oninput = e => {
              if (typeof options.param === "function") {
                options.param($object, e.target.value)
              } else {
                $object.setAttribute(options.param, e.target.value)
              }
              this.render()
            }
            label = document.createElement('label')
            label.appendChild(document.createTextNode(options.title + ' '))
            label.appendChild(input)
            li.appendChild(label)
            break;
        }
        this.element.querySelector('.settings').appendChild(li)
      })
    }

    for (let $control of this.controls) {
      $control._tag = this.element.querySelector('.configure__labels')
      const text = $control._tag.querySelector('textarea[name=labels]')
      const btnAdd = $control._tag.querySelector('.add__labels input[type=button]')
      btnAdd.onclick = () => {
        text.value.split("\n").filter(Boolean).forEach(value => this.labelAdd(value, $control));
        text.value = ""
        this.render()
      }
      for (let $label of $control.children) {
        this.labelInit($label)
      }
    }

    this.render()
  }
}
</script>
